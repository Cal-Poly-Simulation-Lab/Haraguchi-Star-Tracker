Quaternion functions from static image that I don't need anymore 

def q_star(q):
    """
    Computes the quaternion conjugate q*

    Parameters
    ----------
    q : numpy.ndarray
        Quaternion [epsilon; eta]

    Returns
    -------
    q_star : numpy.ndarray
        Quaternion conjugate [epsilon; eta]
    """
    q_star = np.array([[-1 * q[0,0]], [-1 * q[1,0]], [-1 * q[2,0]], [q[3,0]]])
    return q_star

def q_mult_cross(p, q):
    """
    Computes the cross form of quaternion multiplication

    Parameters
    ----------
    p : numpy.ndarray
        First quaternion
    q : numpy.ndarray
        Second quaterion

    Returns
    -------
    q_ret : numpy.ndarray
        Quaternion product 
    """
    q_ret = np.array([p[0] * q[3] - p[1] * q[2] + p[2] * q[1] + p[3] * q[0],
                      p[0] * q[2] - p[2] * q[0] + p[1] * q[3] + p[3] * q[1],
                      p[1] * q[0] - p[0] * q[1] + p[2] * q[3] + p[3] * q[2],
                      p[3] * q[3] - np.vdot(p[0:3], q[0:3])])
    return q_ret

def rot(v, q):
    """
    Rotates vector v by the quaternion q

    Parameters
    ----------
    v : numpy.ndarray
        Vector
    q : numpy.ndarray
        Quaternion

    Returns
    -------
    v_rot : numpy.ndarray
        Rotated vector
    """
    q_s = q_star(q)
    v_q = np.array([v[0], v[1], v[2], [0]])
    v_rot = q_mult_cross(q_mult_cross(q, v_q), q_s)
    v_rot = v_rot[0:3]
    return v_rot

    dynamic image initial try stuff

    # def dynamic_image():
#     cap = cv.VideoCapture("input.mp4")
#     output = cv.VideoWriter( 
#         "output.avi", cv.VideoWriter_fourcc(*'MPEG'), 30, (1080, 1920)) 
  
#     while(True): 
#         ret, frame = cap.read() 
#         if(ret): 
              
#             # adding rectangle on each frame 
#             cv.rectangle(frame, (100, 100), (500, 500), (0, 255, 0), 3) 
              
#             # writing the new frame in output 
#             output.write(frame) 
#             cv.imshow("output", frame) 
#             if cv.waitKey(1) & 0xFF == ord('s'): 
#                 break
  
#     cv.destroyAllWindows() 
#     output.release() 
#     cap.release()

other catalog attempts
    
    # result = Vizier.query_region(coord.SkyCoord(ra=alpha, dec=delta, unit=(units.deg, units.deg), frame='icrs'), height=str(FOVh) + "deg", width=str(FOVv) + "deg", catalog='GSC')

    # table = result[0] 
    # print(table)

    # ra = table[2][:] # what column is what might not be constant??? 
    # dec = table[3][:]
    # print(ra)
    # print(dec)
    # mag = table[5][:]

        # search_string = "sbsc -hn " + str(num_stars) + " -r -7200 " + ra + " " + dec + " J2000"
    # print(search_string)
    # input into command line stuff 
    # subprocess.run(search_string)

    # in real life this would be read in and parsed appropriately
    # catalog_output = np.array([["10:01:00.700", "+31:55:25.00", "5.36"], 
    #                            ["09:59:36.200", "+29:38:43.00", "5.73"], 
    #                            ["10:08:15.900", "+31:36:15.00", "6.24"]])
    
    # # number of stars returned in image may be less than requested 
    # num_stars = np.shape(catalog_output)[1]



    # convert star unit vectors ECI -> camera frame 
    # u_star_camera = np.zeros([num_stars, 3])
    # for i in range(num_stars):
    #     u_star_camera[i,:] = np.matmul(C_camECI, u_star[i,:])

    # find locations of stars on image plane
    # uv_star = np.zeros([num_stars, 2])
    # for i in range(num_stars):
    #     uv_star[i,0] = 

    # im_arr = np.zeros([r, c], dtype = np.uint8)

# really need to check the math on this - declination is proably already in degrees
# def hours2rad(hrs_str):
#     """Converts ra or dec string to equivalent value in radians
    
#     Parameters
#     ----------
#     hrs_str : str
#         Angular value in HH:MM:SS as output from star catalog

#     Returns
#     -------
#     rad : double
#         Angular value in radians 
#     """

#     neg = False
#     if hrs_str[0] == '+':
#         hrs_str = hrs_str[1:]
#     if hrs_str[0] == '-':
#         hrs_str = hrs_str[1:]
#         neg = True
#     hours = float(hrs_str[:2])
#     minutes = float(hrs_str[3:5])
#     sec = float(hrs_str[6:])
#     rad = hours * 15 * np.pi / 180
#     rad += minutes / 60 * np.pi / 180
#     rad += sec / 60 / 60 * np.pi / 180
#     if neg:
#         rad *= -1
#     return rad

# rot = np.array([[1, 0, 0], 
                # [0, 1, 0],
                # [0, 0, 1]])
# static_image("10:00:00", "+30:00:00", 4, 10, 480, 480, rot)